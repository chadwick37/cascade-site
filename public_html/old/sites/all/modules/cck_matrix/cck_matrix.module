<?php

/**
 * Implmentation of hook_form_alter()
 *
 * Disable the multiple values settings.  This module makes use of the Multi Values functionality provided by CCK, but only according to the amount of Rows specified in the settings. We therefore, set this ourselves.
 */
function cck_matrix_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'content_field_edit_form' && $form['#field']['type'] == 'cck_matrix') {
    $form['field']['multiple']['#type'] = 'hidden';
    $form['field']['multiple']['#default_value'] = 1;
  }
}

/**
 *
 * Implementation of hook_field_info()
 *
 * Declare information about a field type.
 *
 * @return
 *   An array keyed by field type name. Each element of the array is an associative
 *   array with these keys and values:
 *   - "label": The human-readable label for the field type.
 *   - "description": A description of the field type.
 */
function cck_matrix_field_info() {
  return array(
      'cck_matrix' => array(
        'label' => t('CCK Matrix Field'),
        'description' => t('Creates a grid of form fields.'),
        ),
      );
}

/**
 * Implementation of hook_field_settings()
 *
 */
function cck_matrix_field_settings($op, $field) {
  include_once drupal_get_path('module', 'cck_matrix') . '/cck_matrix.field_settings.inc';
  switch( $op ) {
    case 'form':
      return cck_matrix_field_settings_form( $field );
    case 'save':
      return cck_matrix_field_settings_save( $field );
    case 'database columns':
      return cck_matrix_field_settings_database_columns($field);
    case 'views data':
      return cck_matrix_field_settings_views($field);
  }
}

/**
 * Implementation of hook_widget_info().
 *
 */
function cck_matrix_widget_info() {
  return array(
      'cck_matrix' => array(
        'label' => 'Text fields in a cck_matrix form',
        'field types' => array('cck_matrix'),
        'multiple values' => CONTENT_HANDLE_MODULE, // We dont want the Weight Handle, as our rows will be defined by the field settings.
        'callbacks' => array(
          'default value' => CONTENT_CALLBACK_DEFAULT, // CONTENT_CALLBACK_NONE, // CONTENT_CALLBACK_DEFAULT
          ),
        'description' => t('A Table CCK Form.'),
        ),
      );
}

/**
 * Implementation of hook_widget()
 *
 */
function cck_matrix_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  $element = array(
      '#type' => $field['widget']['type'],
      '#default_value' => $items, //$items['delta']['data'],
      );
  return $element;
}

/**
 * Implementation of hook_field_formatter_info()
 *
 */
function cck_matrix_field_formatter_info() {
  return array(
      'default' => array(
        'label' => t('Data grid (default)'),
        'field types' => array('cck_matrix'),
        'multiple values' => CONTENT_HANDLE_MODULE,
        ),
      );
}

/**
 * Implementation of hook_theme()
 *
 */
function cck_matrix_theme() {
  return array(
      'cck_matrix_field_settings' => array(
        'arguments' => array('element' => NULL),
        ),
      'cck_matrix_formatter_default' => array(
        'arguments' => array('element' => NULL),
        ),
      'cck_matrix_table_form' => array(
        'arguments' => array('form' => NULL),
        ),
      );
}


/**
 * Implementation of hook_elements()
 *
 */
function cck_matrix_elements() {
  $elements['cck_matrix'] =  array(
      '#input' => TRUE,
      '#delta' => 0,
      '#process' => array('cck_matrix_widget_process'),
      '#element_validate' => array('cck_matrix_validate'),
      );
  return $elements;
}

/**
 *  Implementation of hook_views_api().
 */
function cck_matrix_views_api() {
  return array(
      'api' => 2,
      'path' => drupal_get_path('module', 'cck_matrix') . '/views',
      );
}

/**
 * Supporting Functions
 */

/**
 * Process the matrix type element before displaying the field.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 * The $fields array is in $form['#field_info'][$element['#field_name']].
 */
function cck_matrix_widget_process($element, $edit, &$form_state, $form) {
  $field = $form['#field_info'][$element['#field_name']];
  if ($field['rows'] && $field['cols']) {
    $rows = trim($field['rows']);
    $cols = trim($field['cols']);
    $rows = explode("\n", $rows);
    $cols = explode("\n", $cols);
  }
  $processed_element = array(
      '#tree' => TRUE,
      '#weight' => $field['widget']['weight'],
      '#theme' => 'cck_matrix_table_form',
      '#prefix' => '<div class="form-item cck_matrix_field">',
      '#suffix' => '</div>',
      '#parents' => $element['#parents'],
      '#title' => $element['#title'],
      '#description' => $element['#description'],
      '#required' => $element['#required'],
      '#field_name' => $element['#field_name'],
      '#type_name' => $element['#type_name'],
      '#delta' => $element['#delta'],
      '#columns' => $element['#columns'],
      );

  if ($cols) {
    $header = array_merge(array(''), $cols);
  }

  $first_col = $rows;
  $rows = (array)$rows;
  foreach ($rows as $rkey => $row) {
    if ($row) {
      $row = explode('|', $row);
      foreach ($cols as $ckey=> $col) {
        if ($col) {
          $col = explode('|', $col);
          $processed_element[$rkey][$col[0]] = array(
              '#type' => 'textfield',
              '#size' => $field['size'],
              '#default_value' => isset($edit[$rkey][$col[0]]) ? $edit[$rkey][$col[0]] : $element['#default_value'][$rkey][$col[0]],
              );
        }
      }
    }
  }

  $processed_element['header'] = array('#value' => $header);
  $processed_element['first_col'] = array('#value' => $first_col);
  $processed_element['empty'] = array('#value' => $field['empty']);
  return $processed_element;

}


/**
 * Implementation of hook_content_is_empty().
 *
 */
function cck_matrix_content_is_empty( $item, $field ) {
  // We need to always return FALSE so that our table has the correct delta assignment to each row.
  return FALSE;
}

/**
 * Theme the cck_matrix elements into a table
 */
function theme_cck_matrix_table_form($form) {
  // Set the Headers
  $header = $form['header']['#value'];
  foreach ($header as $key => $header_value) {
    $header_value = explode("|", $header_value);
    $headers['key'][$key] = $header_value[0];
    $headers['label'][$key] = $header_value[1];
  }
  $form['header']['#value'] = $headers['label'];
  
  // Build the Rows
  $rows = array();
  foreach ($form as $rkey => $fields) {
    if (!empty($form['first_col']['#value'][$rkey])) {
      $row = array();
      $label = explode("|", $form['first_col']['#value'][$rkey]);
      $row[$label[0]] = $label[1];
      $i = 0;
      foreach ($fields as $ckey => $field) {
        if ($field['#type'] == 'textfield') {
          $row[$headers['key'][$i]] = drupal_render($form[$rkey][$ckey]);
        }
        $i ++;
      }
      $rows[] = $row;
    }
  }
  drupal_render($form['header']);
  drupal_render($form['first_col']);
  $output = drupal_render($form);
  $output .= theme('table', $headers['label'], $rows, array('class' => 'cck_matrix'));
  return $output;
}

/**
 * Theme function for 'default' text field formatter.
 * This gets called for each row, but we only want to render all the data at once
 * so we use a staticly cached variable to ignore subsquent calls.
 * @param $element The whole $node object, but containing specific information relating to the delta of this element.
 * @return HTML.
 */
function theme_cck_matrix_formatter_default($element) {
  $field_data = $element['#node']->$element['#field_name'];
  $field_info = content_fields($element['#field_name'], $element['#type_name']);

  // Build the Headers
  $header = explode("\n", $field_info['cols']);
  array_unshift($header, '');
  foreach ($header as $key => $header_value) {
    $header_value = explode("|", $header_value);
    $headers['key'][$key] = $header_value[0];
    $headers['label'][$key] = $header_value[1];
  }

  static $rendered; // Since we are rendering the whole thing in one go, we don't want to rerender for each row
  if ($rendered[$element['#node']->nid][$element['#field_name']] != TRUE) {
    $first_col = explode("\n", $field_info['rows']);
    // Add this node to the Redered Array for caching
    $rendered[$element['#node']->nid][$element['#field_name']] = TRUE;
    ksort($field_data);
    foreach ($field_data as $row_index => $row) {
      foreach ($row as $cell_index => $cell_value) {
        if ($cell_value == '') {
          // Replace Blank Cells with the value defined for 'Empty' in Field Settings
          $data[$row_index][$cell_index] = $field_info['empty'];
        }
        else {
          $data[$row_index][$cell_index] = $cell_value;
          $show_row = $row_index;
          $show_table = TRUE;
        }
      }
      // Set the Left Hand Side Labels/Headers
      $label = explode("|", $first_col[$row_index]);
      $row_label =  '<b>'. $label[1] .'</b>';
      array_unshift($data[$row_index], $row_label);
    }

    // Add blank cells if the number of rows/columns is different to the number of headers
    // This can happen when columns/rows are added to an existing content type
    $row_count = count($data[0]);
    if ($row_count < count($header)) {
      for($i = $row_count; $i < count($header['key']); $i++) {
        for ($j = 0; $j < count($data); $j++) {
          $data[$j][$i] = $field_info['empty'];
        }
      }
    }
    // Strip out rows at the end of the dataset where there is no data
    foreach ($data as $row_id => $row) {
      if ($row_id <= $show_row) {
        $flushed_data[] = $row;
      }
    }
    if ($show_table) {
      return theme('table', $headers['label'], $flushed_data);
    }
    else {
      return FALSE;
    }
  }
}
